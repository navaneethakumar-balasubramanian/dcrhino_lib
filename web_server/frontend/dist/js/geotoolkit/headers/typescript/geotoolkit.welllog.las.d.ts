declare module geotoolkit {
    module welllog {
        module data {
            module las {
                /**
                 * LAS Parser
                 */
                class LasParser {
                    /**
                     * LAS Parser
                     */
                    constructor();
                    /**
                     * Return parser appropriate parser for file
                     * @param str  (Required) LAS file input
                     */
                    static getParserInstance(str: string): geotoolkit.welllog.data.las.LasParser;
                    /**
                     * This parser will be generated by JSON using parser grammar
                     * @param str  (Required) input to parse
                     */
                    parse(str: string): any;
                    /**
                     */
                    getSections(): any;
                    /**
                     */
                    getSectionGroups(): any;
                    /**
                     * Detects the type of an LAS file as LAS 2.0 or 3.0
                     * @param str  (Required) LAS file input
                     */
                    detectType(str: string): number;
                    /**
                     * Detects the type of an LAS file wrap or not. Works for all LAS
                     * @param str  (Required) the LAS file to be searched
                     */
                    detectWrap(str: string): boolean;
                    /**
                     * Searches through whole LAS file to determine index unit
                     * @param str  (Required) detectIndexUnit
                     */
                    detectIndexUnit(str: string): string;
                }
                /**
                 * LAS Stream based Parser.<br>
                 * <br>
                 * This is the parent class of LAS parsers using a Stream paradigm.<br>
                 */
                class LasStreamParser {
                    /**
                     * LAS Stream based Parser.<br>
                     * <br>
                     * This is the parent class of LAS parsers using a Stream paradigm.<br>
                     */
                    constructor();
                    /**
                     * Opens the LAS stream and parse its headers.<br>
                     * <br>
                     * The stream can also be opened in 'legacy mode' in order to be accessed like a non-stream based parser.<br>
                     * However this is discouraged as it can lead to memory issues for huge datasets.<br>
                     * <br>
                     * Note that, for convenience, this function returns a Promise AND accepts callbacks (that do not contribute to the returned promise).<br>
                     * One is free to use either the Promise or the callback to be 'notified' when the stream is ready.<br>
                     * @param fullload  (Required) If true, the stream will be fully read and parsed during its opening. (legacy mode)
                     * @param success  (Optional) A function called when the headers have been parsed and the stream is ready
                     * @param error  (Optional) A function called if the header parsing failed
                     */
                    open(fullload: boolean, success?: Function, error?: Function): geotoolkit.util.Promise;
                    /**
                     * Returns the LAS sections
                     */
                    getSections(): any;
                    /**
                     * Returns the LAS section groups
                     */
                    getSectionGroups(): any;
                    /**
                     * Reads data in the given range for the given mnemonics
                     * @param rawDataStart  (Required) The first line for the raw data in the stream
                     * @param fromDepth  (Optional) The first depth to read (no interpolation or extrapolation)
                     * @param toDepth  (Optional) The last depth to read (no interpolation or extrapolation)
                     * @param mnemonics  (Optional) The mnemonics of the curves to retain, if null, all curves will be fetched
                     * @param success  (Optional) A function called when the section has been loaded
                     * @param error  (Optional) A function called if the parsing fails
                     */
                    protected readDataInRange(rawDataStart: number, fromDepth?: number, toDepth?: number, mnemonics?: string[], success?: Function, error?: Function): geotoolkit.util.Promise;
                }
                /**
                 * LAS Parser for LAS version 2.0.
                 */
                class Las20 extends geotoolkit.welllog.data.las.LasParser {
                    /**
                     * LAS Parser for LAS version 2.0.
                     */
                    constructor();
                    /**
                     * Builds string input into our data structures.
                     * @param str  (Required) input to parse
                     */
                    parse(str: string): any;
                    /**
                     * Builds sections to be read
                     */
                    buildSections(): any[];
                    /**
                     * Returns all sections not part of a group
                     */
                    getSections(): geotoolkit.welllog.data.las.LasSection[];
                    /**
                     * Gets all the section groups. Doesn't include sections not in groups.
                     */
                    getSectionGroups(): geotoolkit.welllog.data.las.LasSectionGroup[];
                }
                /**
                 * LAS 3.0 parser implementation
                 */
                class Las30 extends geotoolkit.welllog.data.las.LasParser {
                    /**
                     * LAS 3.0 parser implementation
                     */
                    constructor();
                    /**
                     * Parser done by hand to parse LAS 3.0 files
                     * @param str  (Required) input to parse
                     */
                    parse(str: string): boolean;
                    /**
                     * Private method to build parsed data into section data structures
                     */
                    buildSections(): any[];
                    /**
                     * Returns all sections not part of a group
                     */
                    getSections(): any[];
                    /**
                     * Gets all the section groups. Doesn't include sections not in groups.
                     */
                    getSectionGroups(): any[];
                }
                /**
                 * A section of LAS Data obtained from parser.
                 */
                class LasSection {
                    /**
                     * A section of LAS Data obtained from parser.
                     * @param name  (Required) section name
                     * @param data  (Required) data in current section
                     */
                    constructor(name: string, data: any[]);
                    /**
                     * Gets name
                     */
                    getName(): string;
                    /**
                     * Gets data
                     */
                    getData(): any[];
                    /**
                     * Gets associations of this section
                     */
                    getAssociations(): string;
                }
                /**
                 * LAS Data Section built from an ASCII or _Data section. Holds arrays of data.
                 */
                class LasDataSection {
                    /**
                     * LAS Data Section built from an ASCII or _Data section. Holds arrays of data.
                     */
                    constructor();
                    /**
                     * Returns name of the section
                     */
                    getName(): string;
                    /**
                     * Returns data from the section
                     */
                    getData(): any[];
                    /**
                     * Returns data from the section
                     */
                    getNumeric(): any[];
                    /**
                     * Gets the section that this is associated with
                     */
                    getAssociations(): string;
                }
                /**
                 * A grouping of LAS sections. Used by calling getCurveData with a specific curve mnemonic to get that curve's data
                 */
                class LasSectionGroup {
                    /**
                     * A grouping of LAS sections. Used by calling getCurveData with a specific curve mnemonic to get that curve's data
                     */
                    constructor();
                    /**
                     * Gets the name of this group (prefix)
                     */
                    getName(): string;
                    /**
                     * Gets an array of the sections within this group
                     */
                    getSections(): any;
                    /**
                     * Returns the parameter section
                     */
                    getParameters(): geotoolkit.welllog.data.las.LasParameterSection;
                    /**
                     * Returns the curve parameter
                     * @param mnemonic  (Required) OR index of column for desired data
                     */
                    getCurveInfo(mnemonic: string|number): geotoolkit.welllog.data.las.LasParameter;
                    /**
                     * Returns the curve mnemonics section
                     */
                    getCurveMnemonics(): string[];
                    /**
                     * Return is this data set numeric
                     * @param mnemonic  (Required) OR index of column for desired data
                     */
                    isCurveNumeric(mnemonic: string|number): boolean;
                    /**
                     * Returns the curve data section for specific mnemonic (single curve data as an array)
                     * @param mnemonic  (Required) OR index of column for desired data
                     */
                    getCurveData(mnemonic: string|number): any[];
                }
                /**
                 * A section of LAS Data obtained from parser.
                 */
                class LasParameterSection {
                    /**
                     * A section of LAS Data obtained from parser.
                     */
                    constructor();
                    /**
                     * @param position  (Required) displacement relative to header
                     * @param comment  (Required) comment
                     */
                    addComment(position: number, comment: string): this;
                    /**
                     * Set param
                     * @param mnemonic  (Required) mnemonic
                     * @param unit  (Required) unit
                     * @param value  (Required) value
                     * @param description  (Required) description
                     */
                    setParameter(mnemonic: string, unit: string, value: string, description: string): this;
                    /**
                     * Returns the name of this section
                     */
                    getName(): string;
                    /**
                     * Set section name
                     * @param name  (Required) section name
                     */
                    setName(name: string): this;
                    /**
                     * Gets the data of this section
                     */
                    getData(): any[];
                    /**
                     * Gets value associated with mnemonic in parameter line
                     * The value is parsed as string. It Will be either number or text.
                     * @param mnemonic  (Required) curve mnemonic
                     */
                    getParameterValue(mnemonic: string): number|string;
                }
                /**
                 * A Definition
                 */
                class LasDefinition {
                    /**
                     * A Definition
                     */
                    constructor();
                }
                /**
                 * A single parameter line of LAS data
                 */
                class LasParameter {
                    /**
                     * A single parameter line of LAS data
                     * @param mnemonic  (Required) curve mnemonic
                     * @param unit  (Required) data unit
                     * @param value  (Required) value of parameter
                     * @param description  (Required) description field
                     */
                    constructor(mnemonic: string, unit: string, value: string, description: string);
                    /**
                     * Mnemonic field
                     */
                    getMnemonic(): string;
                    /**
                     * Return unit
                     */
                    getUnit(): string;
                    /**
                     * @param value  (Required) value
                     */
                    setUnit(value: string): this;
                    /**
                     * Returns value of parameter
                     */
                    getValue(): string;
                    /**
                     * @param value  (Required) value
                     */
                    setValue(value: string): this;
                    /**
                     * Return description field
                     */
                    getDescription(): string;
                    /**
                     * @param value  (Required) value
                     */
                    setDescription(value: string): this;
                }
                /**
                 * This class implements a {@link http://www.cwls.org/wp-content/uploads/2014/09/LAS_20_Update_Jan2014.pdf LAS 2.0} parser using a stream paradigm.<br>
                 * <br>
                 * This parser implements an API similar to {@link geotoolkit.welllog.data.las.Las20 Las20} for convenience.<br>
                 * Therefore it will provide {@link geotoolkit.welllog.data.las.LasSection las sections} and {@link geotoolkit.welllog.data.las.LasSectionGroup las section group} like a regular {@link geotoolkit.welllog.data.las.LasParser LASParser}.<br>
                 * <br>
                 * However this stream parser has to be 'opened' to trigger the loading of the stream and the parsing of the sections.<br>
                 * When opening the stream, only the header sections will be loaded and parsed (Version, Well, Curve, Parameter, Other).<br>
                 * The data section won't be loaded nor parsed by default.<br>
                 * <br>
                 * As a result, 'bulk' access to the data using (for example) 'group.getCurveData' will not work.<br>
                 * However the {@link geotoolkit.welllog.data.las.LasStreamDataSection LasStreamDataSection} provides new ways of accessing the data like getDataInRange(startDepth, endDepth).<br>
                 * <br>
                 * Note that, as the LAS 2.0 format has no index, this parser will index it on the fly.<br>
                 * As a consequence, initial getDataInRange calls on a this parser may take longer than subsequent ones.<br>
                 * <br>
                 * Also, to access the data in a not stream based way, it can be forced to read its content fully during the open().<br>
                 * This is discouraged as the purpose of the LasStreamParser is to avoid loading the whole LAS data in memory (to prevent memory issues for large datasets).<br>
                 * If opened in this 'full load' mode, the 'bulk' access to the data will work.<br>
                 * <br>
                 * See the documentation of the open() function for more details.
                 */
                class Las20Stream extends geotoolkit.welllog.data.las.LasStreamParser {
                    /**
                     * This class implements a {@link http://www.cwls.org/wp-content/uploads/2014/09/LAS_20_Update_Jan2014.pdf LAS 2.0} parser using a stream paradigm.<br>
                     * <br>
                     * This parser implements an API similar to {@link geotoolkit.welllog.data.las.Las20 Las20} for convenience.<br>
                     * Therefore it will provide {@link geotoolkit.welllog.data.las.LasSection las sections} and {@link geotoolkit.welllog.data.las.LasSectionGroup las section group} like a regular {@link geotoolkit.welllog.data.las.LasParser LASParser}.<br>
                     * <br>
                     * However this stream parser has to be 'opened' to trigger the loading of the stream and the parsing of the sections.<br>
                     * When opening the stream, only the header sections will be loaded and parsed (Version, Well, Curve, Parameter, Other).<br>
                     * The data section won't be loaded nor parsed by default.<br>
                     * <br>
                     * As a result, 'bulk' access to the data using (for example) 'group.getCurveData' will not work.<br>
                     * However the {@link geotoolkit.welllog.data.las.LasStreamDataSection LasStreamDataSection} provides new ways of accessing the data like getDataInRange(startDepth, endDepth).<br>
                     * <br>
                     * Note that, as the LAS 2.0 format has no index, this parser will index it on the fly.<br>
                     * As a consequence, initial getDataInRange calls on a this parser may take longer than subsequent ones.<br>
                     * <br>
                     * Also, to access the data in a not stream based way, it can be forced to read its content fully during the open().<br>
                     * This is discouraged as the purpose of the LasStreamParser is to avoid loading the whole LAS data in memory (to prevent memory issues for large datasets).<br>
                     * If opened in this 'full load' mode, the 'bulk' access to the data will work.<br>
                     * <br>
                     * See the documentation of the open() function for more details.
                     * @param options  (Required) The options
                     * @param options.reader  (Required) The data source for this stream
                     */
                    constructor(options: any | { reader?: geotoolkit.util.stream.LineReader; } );
                    /**
                     * Opens the LAS 2.0 stream and parse its headers.<br>
                     * <br>
                     * The stream can also be opened in 'legacy mode' in order to be accessed like a non-stream based parser.<br>
                     * However this is discouraged as it can lead to memory issues for huge dataset.<br>
                     * <br>
                     * Once this stream has been opened, its 'header' sections can be accessed using getSections().<br>
                     * See example for accessing the data in either 'legacy/non-stream' mode or 'stream' mode.<br>
                     * <br>
                     * Note that, for convenience, this function returns a Promise AND accepts callbacks (that do not contribute to the returned promise).<br>
                     * One is free to use either the Promise or the callback to be 'notified' when the stream is ready.<br>
                     * @param fullload  (Required) If true, the stream will be fully read and parsed during its opening. (This is discouraged)
                     * @param success  (Optional) A function called when the headers have been parsed and the stream is ready
                     * @param error  (Optional) A function called if the header parsing failed
                     */
                    open(fullload: boolean, success?: Function, error?: Function): geotoolkit.util.Promise;
                    /**
                     * Gets all the section groups. Doesn't include sections not in groups.
                     */
                    getSectionGroups(): geotoolkit.welllog.data.las.LasSectionGroup[];
                    /**
                     * Returns all sections not part of a group
                     */
                    getSections(): geotoolkit.welllog.data.las.LasSection[];
                    /**
                     * Reads data in the given range for the given mnemonics.<br>
                     * @param rawDataStart  (Required) The line index of the data section
                     * @param fromDepth  (Optional) The first depth to read (no interpolation or extrapolation)
                     * @param toDepth  (Optional) The last depth to read (no interpolation or extrapolation)
                     * @param mnemonics  (Optional) The mnemonics of the curves to retain, if null, all curves will be fetched
                     * @param success  (Optional) A function called when the section has been loaded
                     * @param error  (Optional) A function called if the parsing fails
                     */
                    protected readDataInRange(rawDataStart: number, fromDepth?: number, toDepth?: number, mnemonics?: string[], success?: Function, error?: Function): geotoolkit.util.Promise;
                    /**
                     * Reads data in the given range for the given mnemonics.<br>
                     * @param rawDataStart  (Required) The line index of the data section
                     * @param fromDepth  (Optional) The first depth to read (no interpolation or extrapolation)
                     * @param toDepth  (Optional) The last depth to read (no interpolation or extrapolation)
                     * @param indexes  (Optional) The index of the curves to retain, if null, all curves will be fetched
                     * @param success  (Optional) A function called when the section has been loaded
                     * @param error  (Optional) A function called if the parsing fails
                     */
                    protected readDataInRangeByIndex(rawDataStart: number, fromDepth?: number, toDepth?: number, indexes?: number[], success?: Function, error?: Function): geotoolkit.util.Promise;
                    /**
                     * Tests if the given reader looks like a LAS 2.0<br>
                     * Note that a success does not mean that the given reader is a LAS 2.0 but only that the type has been detected.<br>
                     * To find out if it is a LAS 2.0, one should look at the result given in the promise/callback.<br>
                     * {isLAS20:true, details:"Mode information about the isLAS20 result"}<br>
                     * <br>
                     * Note that, for convenience, this function returns a Promise AND accepts callbacks (that do not contribute to the returned promise).<br>
                     * One is free to use either the Promise or the callback to be 'notified' when the stream is ready.<br>
                     * <br>
                     * @param reader  (Required) The reader to test
                     * @param success  (Optional) A function called when the nature of the given reader has been detected
                     * @param error  (Optional) A function called if a major error occurs
                     */
                    static isLAS20(reader: geotoolkit.util.stream.LineReader, success?: Function, error?: Function): geotoolkit.util.Promise;
                }
                /**
                 * A LAS Data Section supporting stream access.
                 */
                class LasStreamDataSection extends geotoolkit.welllog.data.las.LasDataSection {
                    /**
                     * A LAS Data Section supporting stream access.
                     * @param stream  (Required) The underlying LAS stream
                     */
                    constructor(stream: geotoolkit.welllog.data.las.LasStreamParser);
                    /**
                     * Reads the values for the given range.<br>
                     * Note that the range will not be extrapolated nor the values interpolated in the case the given start/end do not exist in the file (see examples).<br>
                     * <br>
                     * Also, this function will not reorder the data nor reorder the given start/end (if start > depth).<br>
                     * It assumes those are coherent with the LAS data order.<br>
                     * For example, providing start>end for a dataset that has an increasing index will not work properly.<br>
                     * <br>
                     * Note that, for convenience, this function returns a Promise AND accepts callbacks (that do not contribute to the returned promise).<br>
                     * One is free to use either the Promise or the callback to be 'notified' when the stream is ready.<br>
                     * <br>
                     * @param start  (Optional) The first depth to read (no interpolation or extrapolation)
                     * @param end  (Optional) The last depth to read (no interpolation or extrapolation)
                     * @param mnemonics  (Optional) The mnemonics of the curves to retain, if null, all curves will be fetched
                     * @param success  (Optional) A function called when the range has been read
                     * @param error  (Optional) A function called if the parsing fails
                     */
                    getDataInRange(start?: number, end?: number, mnemonics?: string[], success?: Function, error?: Function): geotoolkit.util.Promise;
                    /**
                     * Reads the values for the given range.<br>
                     * Note that the range will not be extrapolated nor the values interpolated in the case the given start/end do not exist in the file (see examples).<br>
                     * <br>
                     * Also, this function will not reorder the data nor reorder the given start/end (if start > depth).<br>
                     * It assumes those are coherent with the LAS data order.<br>
                     * For example, providing start>end for a dataset that has an increasing index will not work properly.<br>
                     * <br>
                     * Note that, for convenience, this function returns a Promise AND accepts callbacks (that do not contribute to the returned promise).<br>
                     * One is free to use either the Promise or the callback to be 'notified' when the stream is ready.<br>
                     * <br>
                     * @param start  (Optional) The first depth to read (no interpolation or extrapolation)
                     * @param end  (Optional) The last depth to read (no interpolation or extrapolation)
                     * @param indexes  (Optional) The indexes of the curves to retain, if null, all curves will be fetched
                     * @param success  (Optional) A function called when the range has been read
                     * @param error  (Optional) A function called if the parsing fails
                     */
                    getDataInRangeByIndex(start?: number, end?: number, indexes?: number[], success?: Function, error?: Function): geotoolkit.util.Promise;
                }
                /**
                 * LAS writer for LAS version 2.0
                 */
                class Las20Writer {
                    /**
                     * LAS writer for LAS version 2.0
                     * @param indexData  (Required) data series which stores index values (depth, time or index)
                     */
                    constructor(indexData: geotoolkit.data.NumericalDataSeries);
                    /**
                     * Sets company name
                     * @param value  (Required) value
                     */
                    setCompanyName(value: string): this;
                    /**
                     * Sets well name
                     * @param value  (Required) value
                     */
                    setWellName(value: string): this;
                    /**
                     * Sets field
                     * @param value  (Required) value
                     */
                    setField(value: string): this;
                    /**
                     * Sets location
                     * @param value  (Required) value
                     */
                    setLocation(value: string): this;
                    /**
                     * Sets province
                     * @param value  (Required) value
                     */
                    setProvince(value: string): this;
                    /**
                     * Sets county
                     * @param value  (Required) value
                     */
                    setCounty(value: string): this;
                    /**
                     * Sets state
                     * @param value  (Required) value
                     */
                    setState(value: string): this;
                    /**
                     * Sets country
                     * @param value  (Required) value
                     */
                    setCountry(value: string): this;
                    /**
                     * Sets service company
                     * @param value  (Required) value
                     */
                    setServiceCompany(value: string): this;
                    /**
                     * Sets date
                     * @param value  (Required) value
                     */
                    setDate(value: string): this;
                    /**
                     * Sets unique well id
                     * @param value  (Required) value
                     */
                    setUWI(value: string): this;
                    /**
                     * Sets API number
                     * @param value  (Required) value
                     */
                    setAPINumber(value: string): this;
                    /**
                     * Sets licence number
                     * @param value  (Required) value
                     */
                    setLicenceNumber(value: string): this;
                    /**
                     * Save
                     * @param stream  (Required) stream to save file
                     */
                    save(stream: geotoolkit.util.stream.Stream): any;
                    /**
                     * Adds parameter
                     * @param mnemonic  (Required) mnemonic
                     * @param unit  (Required) unit
                     * @param value  (Required) value
                     * @param description  (Required) description
                     */
                    addParameter(mnemonic: string, unit: string, value: string, description: string): this;
                    /**
                     * @param curveData  (Required) curve data series
                     * @param mnemonic  (Optional) mnemonic
                     * @param unit  (Optional) unit
                     * @param value  (Optional) value
                     * @param description  (Optional) description
                     */
                    addCurve(curveData: geotoolkit.data.NumericalDataSeries, mnemonic?: string, unit?: string, value?: string, description?: string): this;
                    /**
                     * Adds comment to version section
                     * @param position  (Required) position
                     * @param comment  (Required) comment
                     */
                    addVersionComment(position: number, comment: string): this;
                    /**
                     * Adds comment to well section
                     * @param position  (Required) position
                     * @param comment  (Required) comment
                     */
                    addWellComment(position: number, comment: string): this;
                    /**
                     * Adds comment to parameter section
                     * @param position  (Required) position
                     * @param comment  (Required) comment
                     */
                    addParameterComment(position: number, comment: string): this;
                    /**
                     * Adds comment to curve section
                     * @param position  (Required) position
                     * @param comment  (Required) comment
                     */
                    addCurveComment(position: number, comment: string): this;
                    /**
                     * @param value  (Required) null value
                     */
                    setNullValue(value: number): this;
                    /**
                     */
                    getNullValue(): number;
                }
            }
        }
    }
}
