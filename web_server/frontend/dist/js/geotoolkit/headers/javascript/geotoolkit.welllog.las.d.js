/** @namespace */
geotoolkit.welllog.data.las = {};

/**
 * LAS Parser
 *
 * @class geotoolkit.welllog.data.las.LasParser
 */
geotoolkit.welllog.data.las.LasParser = {};
    /**
     * Return parser appropriate parser for file
     *
     * @param {string} str
     * LAS file input
     * @returns {geotoolkit.welllog.data.las.LasParser}
     */
    geotoolkit.welllog.data.las.LasParser.getParserInstance = function(str){};
    /**
     * This parser will be generated by JSON using parser grammar
     *
     * @function
     * @abstract
     * @param {string} str input to parse
     * @throws {Error} when invoked to indicate the method should be overridden.
     */
    geotoolkit.welllog.data.las.LasParser.prototype.parse = function(str){};
    /**
     *
     * @function
     * @abstract
     * @throws {Error} when invoked to indicate the method should be overridden.
     */
    geotoolkit.welllog.data.las.LasParser.prototype.getSections = function(){};
    /**
     * @function
     * @abstract
     * @throws {Error} to show the method should be overridden
     */
    geotoolkit.welllog.data.las.LasParser.prototype.getSectionGroups = function(){};
    /**
     * Detects the type of an LAS file as LAS 2.0 or 3.0
     *
     * @param {string} str LAS file input
     * @returns {number}
     */
    geotoolkit.welllog.data.las.LasParser.prototype.detectType = function(str){};
    /**
     * Detects the type of an LAS file wrap or not. Works for all LAS
     *
     * @returns {boolean} wrap
     * @param {string} str the LAS file to be searched
     */
    geotoolkit.welllog.data.las.LasParser.prototype.detectWrap = function(str){};
    /**
     * Searches through whole LAS file to determine index unit
     *
     * @param {string} str detectIndexUnit
     * @returns {string}
     */
    geotoolkit.welllog.data.las.LasParser.prototype.detectIndexUnit = function(str){};

/**
 * LAS Stream based Parser.<br>
 * <br>
 * This is the parent class of LAS parsers using a Stream paradigm.<br>
 *
 * @class geotoolkit.welllog.data.las.LasStreamParser
 */
geotoolkit.welllog.data.las.LasStreamParser = {};
    /**
     * @function
     * @desc
     * Opens the LAS stream and parse its headers.<br>
     * <br>
     * The stream can also be opened in 'legacy mode' in order to be accessed like a non-stream based parser.<br>
     * However this is discouraged as it can lead to memory issues for huge datasets.<br>
     * <br>
     * Note that, for convenience, this function returns a Promise AND accepts callbacks (that do not contribute to the returned promise).<br>
     * One is free to use either the Promise or the callback to be 'notified' when the stream is ready.<br>
     *
     * @param {boolean} fullload If true, the stream will be fully read and parsed during its opening. (legacy mode)
     * @param {function} [success] A function called when the headers have been parsed and the stream is ready
     * @param {function} [error] A function called if the header parsing failed
     * @returns {geotoolkit.util.Promise} A promise fulfilled when the headers have been parsed and the stream is ready
     */
    geotoolkit.welllog.data.las.LasStreamParser.prototype.open = function(fullload, success, error){};
    /**
     * Returns the LAS sections
     * @function
     * @abstract
     */
    geotoolkit.welllog.data.las.LasStreamParser.prototype.getSections = function(){};
    /**
     * Returns the LAS section groups
     * @function
     * @abstract
     */
    geotoolkit.welllog.data.las.LasStreamParser.prototype.getSectionGroups = function(){};
    /**
     * @function
     * @desc
     * Reads data in the given range for the given mnemonics
     * @param {number} rawDataStart The first line for the raw data in the stream
     * @param {number} [fromDepth] The first depth to read (no interpolation or extrapolation)
     * @param {number} [toDepth] The last depth to read (no interpolation or extrapolation)
     * @param {string[]} [mnemonics=null] The mnemonics of the curves to retain, if null, all curves will be fetched
     * @param {function} [success] A function called when the section has been loaded
     * @param {function} [error] A function called if the parsing fails
     * @returns {geotoolkit.util.Promise} A promise fulfilled when the data has been read
     * @protected
     */
    geotoolkit.welllog.data.las.LasStreamParser.prototype.readDataInRange = function(rawDataStart, fromDepth, toDepth, mnemonics, success, error){};

/**
 * LAS Parser for LAS version 2.0.
 *
 * @class geotoolkit.welllog.data.las.Las20
 * @augments geotoolkit.welllog.data.las.LasParser
 */
geotoolkit.welllog.data.las.Las20 = {};
    /**
     * Builds string input into our data structures.
     *
     * @param {string} str input to parse
     * @returns {object} with parsed contents
     * @throws {Error} when invoked to indicate the method should be overridden.
     */
    geotoolkit.welllog.data.las.Las20.prototype.parse = function(str){};
    /**
     * Builds sections to be read
     *
     * @returns {Array}
     */
    geotoolkit.welllog.data.las.Las20.prototype.buildSections = function(){};
    /**
     * Returns all sections not part of a group
     *
     * @throws {Error} when invoked to indicate the method should be overridden.
     * @returns {geotoolkit.welllog.data.las.LasSection[]} array of LasSection
     */
    geotoolkit.welllog.data.las.Las20.prototype.getSections = function(){};
    /**
     * Gets all the section groups. Doesn't include sections not in groups.
     *
     * @returns {geotoolkit.welllog.data.las.LasSectionGroup[]} array of LasSectionGroup
     */
    geotoolkit.welllog.data.las.Las20.prototype.getSectionGroups = function(){};

/**
 * LAS 3.0 parser implementation
 *
 * @class geotoolkit.welllog.data.las.Las30
 * @augments geotoolkit.welllog.data.las.LasParser
 */
geotoolkit.welllog.data.las.Las30 = {};
    /**
     * Parser done by hand to parse LAS 3.0 files
     *
     * @param {string} str input to parse
     * @returns {boolean} valid: ran successfully or not
     */
    geotoolkit.welllog.data.las.Las30.prototype.parse = function(str){};
    /**
     * Private method to build parsed data into section data structures
     *
     * @returns {Array}
     */
    geotoolkit.welllog.data.las.Las30.prototype.buildSections = function(){};
    /**
     * Returns all sections not part of a group
     *
     * @throws {Error} when invoked to indicate the method should be overridden.
     * @returns {Array}
     */
    geotoolkit.welllog.data.las.Las30.prototype.getSections = function(){};
    /**
     * Gets all the section groups. Doesn't include sections not in groups.
     *
     * @returns {Array}
     */
    geotoolkit.welllog.data.las.Las30.prototype.getSectionGroups = function(){};

/**
 * A section of LAS Data obtained from parser.
 *
 * @class geotoolkit.welllog.data.las.LasSection
 * @param {string} name section name
 * @param {array} data data in current section
 */
geotoolkit.welllog.data.las.LasSection = {};
    /**
     * Gets name
     *
     * @returns {string}
     */
    geotoolkit.welllog.data.las.LasSection.prototype.getName = function(){};
    /**
     * Gets data
     *
     * @returns {array}
     */
    geotoolkit.welllog.data.las.LasSection.prototype.getData = function(){};
    /**
     * Gets associations of this section
     *
     * @returns {string}
     */
    geotoolkit.welllog.data.las.LasSection.prototype.getAssociations = function(){};

/**
 * LAS Data Section built from an ASCII or _Data section. Holds arrays of data.
 *
 * @class geotoolkit.welllog.data.las.LasDataSection
 */
geotoolkit.welllog.data.las.LasDataSection = {};
    /**
     * Returns name of the section
     * @returns {string}
     */
    geotoolkit.welllog.data.las.LasDataSection.prototype.getName = function(){};
    /**
     * Returns data from the section
     * @returns {Array}
     */
    geotoolkit.welllog.data.las.LasDataSection.prototype.getData = function(){};
    /**
     * Returns data from the section
     * @returns {Array}
     */
    geotoolkit.welllog.data.las.LasDataSection.prototype.getNumeric = function(){};
    /**
     * Gets the section that this is associated with
     *
     * @returns {string}
     */
    geotoolkit.welllog.data.las.LasDataSection.prototype.getAssociations = function(){};

/**
 * A grouping of LAS sections. Used by calling getCurveData with a specific curve mnemonic to get that curve's data
 *
 * @class geotoolkit.welllog.data.las.LasSectionGroup
 */
geotoolkit.welllog.data.las.LasSectionGroup = {};
    /**
     * Gets the name of this group (prefix)
     *
     * @returns {string}
     */
    geotoolkit.welllog.data.las.LasSectionGroup.prototype.getName = function(){};
    /**
     * Gets an array of the sections within this group
     *
     * @returns {object}
     */
    geotoolkit.welllog.data.las.LasSectionGroup.prototype.getSections = function(){};
    /**
     * Returns the parameter section
     *
     * @returns {geotoolkit.welllog.data.las.LasParameterSection}
     */
    geotoolkit.welllog.data.las.LasSectionGroup.prototype.getParameters = function(){};
    /**
     * Returns the curve parameter
     * @param {string | number} mnemonic OR index of column for desired data
     * @returns {geotoolkit.welllog.data.las.LasParameter}
     */
    geotoolkit.welllog.data.las.LasSectionGroup.prototype.getCurveInfo = function(mnemonic){};
    /**
     * Returns the curve mnemonics section
     *
     * @returns {String[]} mnemonics
     */
    geotoolkit.welllog.data.las.LasSectionGroup.prototype.getCurveMnemonics = function(){};
    /**
     * Return is this data set numeric
     *
     * @param {string | number} mnemonic OR index of column for desired data
     * @returns {boolean}
     */
    geotoolkit.welllog.data.las.LasSectionGroup.prototype.isCurveNumeric = function(mnemonic){};
    /**
     * Returns the curve data section for specific mnemonic (single curve data as an array)
     *
     * @param {string | number} mnemonic OR index of column for desired data
     * @returns {Array}
     */
    geotoolkit.welllog.data.las.LasSectionGroup.prototype.getCurveData = function(mnemonic){};

/**
 * A section of LAS Data obtained from parser.
 *
 * @class geotoolkit.welllog.data.las.LasParameterSection
 */
geotoolkit.welllog.data.las.LasParameterSection = {};
    /**
     *
     * @param {number} position displacement relative to header
     * @param {string} comment comment
     * @returns {geotoolkit.welllog.data.las.LasParameterSection}
     */
    geotoolkit.welllog.data.las.LasParameterSection.prototype.addComment = function(position, comment){};
    /**
     * Set param
     * @param {string} mnemonic mnemonic
     * @param {string} unit unit
     * @param {string} value value
     * @param {string} description description
     * @returns {geotoolkit.welllog.data.las.LasParameterSection}
     */
    geotoolkit.welllog.data.las.LasParameterSection.prototype.setParameter = function(mnemonic, unit, value, description){};
    /**
     * Returns the name of this section
     * @returns {string}
     */
    geotoolkit.welllog.data.las.LasParameterSection.prototype.getName = function(){};
    /**
     * Set section name
     * @param {string} name section name
     * @returns {geotoolkit.welllog.data.las.LasParameterSection}
     */
    geotoolkit.welllog.data.las.LasParameterSection.prototype.setName = function(name){};
    /**
     * Gets the data of this section
     * @returns {Array}
     */
    geotoolkit.welllog.data.las.LasParameterSection.prototype.getData = function(){};
    /**
     * Gets value associated with mnemonic in parameter line
     * The value is parsed as string. It Will be either number or text.
     *
     * @param {string} mnemonic curve mnemonic
     * @returns {number|string}
     */
    geotoolkit.welllog.data.las.LasParameterSection.prototype.getParameterValue = function(mnemonic){};

/**
 * A Definition
 *
 * @class geotoolkit.welllog.data.las.LasDefinition
 */
geotoolkit.welllog.data.las.LasDefinition = {};

/**
 * A single parameter line of LAS data
 *
 * @class geotoolkit.welllog.data.las.LasParameter
 * @param {string} mnemonic curve mnemonic
 * @param {string} unit data unit
 * @param {string} value value of parameter
 * @param {string} description description field
 */
geotoolkit.welllog.data.las.LasParameter = {};
    /**
     * Mnemonic field
     *
     * @returns {string}
     */
    geotoolkit.welllog.data.las.LasParameter.prototype.getMnemonic = function(){};
    /**
     * Return unit
     *
     * @returns {string}
     */
    geotoolkit.welllog.data.las.LasParameter.prototype.getUnit = function(){};
    /**
     *
     * @param {string} value value
     * @returns {geotoolkit.welllog.data.las.LasParameter}
     */
    geotoolkit.welllog.data.las.LasParameter.prototype.setUnit = function(value){};
    /**
     * Returns value of parameter
     *
     * @returns {string}
     */
    geotoolkit.welllog.data.las.LasParameter.prototype.getValue = function(){};
    /**
     *
     * @param {string} value value
     * @returns {geotoolkit.welllog.data.las.LasParameter}
     */
    geotoolkit.welllog.data.las.LasParameter.prototype.setValue = function(value){};
    /**
     * Return description field
     *
     * @returns {string}
     */
    geotoolkit.welllog.data.las.LasParameter.prototype.getDescription = function(){};
    /**
     *
     * @param {string} value value
     * @returns {geotoolkit.welllog.data.las.LasParameter}
     */
    geotoolkit.welllog.data.las.LasParameter.prototype.setDescription = function(value){};

/**
 * This class implements a {@link http://www.cwls.org/wp-content/uploads/2014/09/LAS_20_Update_Jan2014.pdf LAS 2.0} parser using a stream paradigm.<br>
 * <br>
 * This parser implements an API similar to {@link geotoolkit.welllog.data.las.Las20 Las20} for convenience.<br>
 * Therefore it will provide {@link geotoolkit.welllog.data.las.LasSection las sections} and {@link geotoolkit.welllog.data.las.LasSectionGroup las section group} like a regular {@link geotoolkit.welllog.data.las.LasParser LASParser}.<br>
 * <br>
 * However this stream parser has to be 'opened' to trigger the loading of the stream and the parsing of the sections.<br>
 * When opening the stream, only the header sections will be loaded and parsed (Version, Well, Curve, Parameter, Other).<br>
 * The data section won't be loaded nor parsed by default.<br>
 * <br>
 * As a result, 'bulk' access to the data using (for example) 'group.getCurveData' will not work.<br>
 * However the {@link geotoolkit.welllog.data.las.LasStreamDataSection LasStreamDataSection} provides new ways of accessing the data like getDataInRange(startDepth, endDepth).<br>
 * <br>
 * Note that, as the LAS 2.0 format has no index, this parser will index it on the fly.<br>
 * As a consequence, initial getDataInRange calls on a this parser may take longer than subsequent ones.<br>
 * <br>
 * Also, to access the data in a not stream based way, it can be forced to read its content fully during the open().<br>
 * This is discouraged as the purpose of the LasStreamParser is to avoid loading the whole LAS data in memory (to prevent memory issues for large datasets).<br>
 * If opened in this 'full load' mode, the 'bulk' access to the data will work.<br>
 * <br>
 * See the documentation of the open() function for more details.
 *
 * @class geotoolkit.welllog.data.las.Las20Stream
 * @augments geotoolkit.welllog.data.las.LasStreamParser
 * @param {object} options The options
 * @param {geotoolkit.util.stream.LineReader} options.reader The data source for this stream
 */
geotoolkit.welllog.data.las.Las20Stream = {};
    /**
     * Opens the LAS 2.0 stream and parse its headers.<br>
     * <br>
     * The stream can also be opened in 'legacy mode' in order to be accessed like a non-stream based parser.<br>
     * However this is discouraged as it can lead to memory issues for huge dataset.<br>
     * <br>
     * Once this stream has been opened, its 'header' sections can be accessed using getSections().<br>
     * See example for accessing the data in either 'legacy/non-stream' mode or 'stream' mode.<br>
     * <br>
     * Note that, for convenience, this function returns a Promise AND accepts callbacks (that do not contribute to the returned promise).<br>
     * One is free to use either the Promise or the callback to be 'notified' when the stream is ready.<br>
     *
     * @param {boolean} fullload If true, the stream will be fully read and parsed during its opening. (This is discouraged)
     * @param {function} [success] A function called when the headers have been parsed and the stream is ready
     * @param {function} [error] A function called if the header parsing failed
     * @returns {geotoolkit.util.Promise} A promise fulfilled when the headers have been parsed and the stream is ready
     * @example
     * // Non stream based access
     * var stream = new geotoolkit.welllog.data.las.Las20Stream({
     * 'reader': new geotoolkit.util.stream.LineReader({
     * 'stream': new geotoolkit.util.stream.BrowserFileStream({
     * 'file': file
     * })
     * })
     * }).open(true).then(function (stream) {
     * var datasection = stream.getSectionGroups()[0];
     * var group = stream.getSectionGroups()[0]
     * var curvevalues = group.getCurveData(group.getCurveMnemonics()[0])
     * }, function(error) {});
     * @example
     * // Stream based access
     * var stream = new geotoolkit.welllog.data.las.Las20Stream({
     * 'reader': new geotoolkit.util.stream.LineReader({
     * 'stream': new geotoolkit.util.stream.BrowserFileStream({
     * 'file': file
     * })
     * })
     * }).open().then(function (stream) {
     * var datasection = stream.getSectionGroups()[0].getSections()['data'];
     * datasection.getDataInRange(5700, 5750, ['GR']).then(function (data) {
     * console.log('range 5700 5750 => ' + data[0].length + ' values');
     * }, function (error) {});
     * });
     */
    geotoolkit.welllog.data.las.Las20Stream.prototype.open = function(fullload, success, error){};
    /**
     * Gets all the section groups. Doesn't include sections not in groups.
     *
     * @returns {geotoolkit.welllog.data.las.LasSectionGroup[]} array of LasSectionGroup
     */
    geotoolkit.welllog.data.las.Las20Stream.prototype.getSectionGroups = function(){};
    /**
     * Returns all sections not part of a group
     *
     * @returns {geotoolkit.welllog.data.las.LasSection[]} array of LasSection
     */
    geotoolkit.welllog.data.las.Las20Stream.prototype.getSections = function(){};
    /**
     * Reads data in the given range for the given mnemonics.<br>
     * @param {number} rawDataStart The line index of the data section
     * @param {number} [fromDepth] The first depth to read (no interpolation or extrapolation)
     * @param {number} [toDepth] The last depth to read (no interpolation or extrapolation)
     * @param {string[]} [mnemonics=null] The mnemonics of the curves to retain, if null, all curves will be fetched
     * @param {function} [success] A function called when the section has been loaded
     * @param {function} [error] A function called if the parsing fails
     * @returns {geotoolkit.util.Promise} A promise fulfilled when the data has been read
     * @protected
     */
    geotoolkit.welllog.data.las.Las20Stream.prototype.readDataInRange = function(rawDataStart, fromDepth, toDepth, mnemonics, success, error){};
    /**
     * Reads data in the given range for the given mnemonics.<br>
     * @param {number} rawDataStart The line index of the data section
     * @param {number} [fromDepth] The first depth to read (no interpolation or extrapolation)
     * @param {number} [toDepth] The last depth to read (no interpolation or extrapolation)
     * @param {number[]} [indexes=null] The index of the curves to retain, if null, all curves will be fetched
     * @param {function} [success] A function called when the section has been loaded
     * @param {function} [error] A function called if the parsing fails
     * @returns {geotoolkit.util.Promise} A promise fulfilled when the data has been read
     * @protected
     */
    geotoolkit.welllog.data.las.Las20Stream.prototype.readDataInRangeByIndex = function(rawDataStart, fromDepth, toDepth, indexes, success, error){};
    /**
     * Tests if the given reader looks like a LAS 2.0<br>
     * Note that a success does not mean that the given reader is a LAS 2.0 but only that the type has been detected.<br>
     * To find out if it is a LAS 2.0, one should look at the result given in the promise/callback.<br>
     * {isLAS20:true, details:"Mode information about the isLAS20 result"}<br>
     * <br>
     * Note that, for convenience, this function returns a Promise AND accepts callbacks (that do not contribute to the returned promise).<br>
     * One is free to use either the Promise or the callback to be 'notified' when the stream is ready.<br>
     * <br>
     * @param {geotoolkit.util.stream.LineReader} reader The reader to test
     * @param {function} [success] A function called when the nature of the given reader has been detected
     * @param {function} [error] A function called if a major error occurs
     * @returns {geotoolkit.util.Promise} A promise fulfilled when the nature of the given reader has been detected
     * @example
     * geotoolkit.welllog.data.las.Las20Stream.isLAS20(lineReader).then(function (result) {
     * if (result['isLAS20'] === true) {
     * console.log(result['details']);
     * // Can be parsed using geotoolkit.welllog.data.las.Las20Stream
     * } else {
     * console.log(result['details']);
     * // Can't be parsed using geotoolkit.welllog.data.las.Las20Stream
     * }
     * }, function (result) {
     * console.log(result['details']);
     * // Can't be parsed using geotoolkit.welllog.data.las.Las20Stream
     * });
     */
    geotoolkit.welllog.data.las.Las20Stream.isLAS20 = function(reader, success, error){};

/**
 * A LAS Data Section supporting stream access.
 *
 * @param {geotoolkit.welllog.data.las.LasStreamParser} stream The underlying LAS stream
 *
 * @class geotoolkit.welllog.data.las.LasStreamDataSection
 * @augments geotoolkit.welllog.data.las.LasDataSection
 */
geotoolkit.welllog.data.las.LasStreamDataSection = {};
    /**
     * Reads the values for the given range.<br>
     * Note that the range will not be extrapolated nor the values interpolated in the case the given start/end do not exist in the file (see examples).<br>
     * <br>
     * Also, this function will not reorder the data nor reorder the given start/end (if start > depth).<br>
     * It assumes those are coherent with the LAS data order.<br>
     * For example, providing start>end for a dataset that has an increasing index will not work properly.<br>
     * <br>
     * Note that, for convenience, this function returns a Promise AND accepts callbacks (that do not contribute to the returned promise).<br>
     * One is free to use either the Promise or the callback to be 'notified' when the stream is ready.<br>
     * <br>
     * @param {number} [start=STREAM_START] The first depth to read (no interpolation or extrapolation)
     * @param {number} [end=STREAM_END] The last depth to read (no interpolation or extrapolation)
     * @param {string[]} [mnemonics=null] The mnemonics of the curves to retain, if null, all curves will be fetched
     * @param {function} [success] A function called when the range has been read
     * @param {function} [error] A function called if the parsing fails
     * @returns {geotoolkit.util.Promise} A promise fulfilled when the range has been read
     * @example
     * // File depths: 10,20,30,40
     * // getDataInRange(0,20) => values returned are for depths [10, 20]
     * // getDataInRange(30,50) => values returned are for depths [30, 40]
     * // getDataInRange(35,50) => values returned are for depths [40]
     * // getDataInRange(5,15) => values returned are for depths [10]
     */
    geotoolkit.welllog.data.las.LasStreamDataSection.prototype.getDataInRange = function(start, end, mnemonics, success, error){};
    /**
     * Reads the values for the given range.<br>
     * Note that the range will not be extrapolated nor the values interpolated in the case the given start/end do not exist in the file (see examples).<br>
     * <br>
     * Also, this function will not reorder the data nor reorder the given start/end (if start > depth).<br>
     * It assumes those are coherent with the LAS data order.<br>
     * For example, providing start>end for a dataset that has an increasing index will not work properly.<br>
     * <br>
     * Note that, for convenience, this function returns a Promise AND accepts callbacks (that do not contribute to the returned promise).<br>
     * One is free to use either the Promise or the callback to be 'notified' when the stream is ready.<br>
     * <br>
     * @param {number} [start=STREAM_START] The first depth to read (no interpolation or extrapolation)
     * @param {number} [end=STREAM_END] The last depth to read (no interpolation or extrapolation)
     * @param {number[]} [indexes=null] The indexes of the curves to retain, if null, all curves will be fetched
     * @param {function} [success] A function called when the range has been read
     * @param {function} [error] A function called if the parsing fails
     * @returns {geotoolkit.util.Promise} A promise fulfilled when the range has been read
     * @example
     * // File depths: 10,20,30,40
     * // getDataInRange(0,20) => values returned are for depths [10, 20]
     * // getDataInRange(30,50) => values returned are for depths [30, 40]
     * // getDataInRange(35,50) => values returned are for depths [40]
     * // getDataInRange(5,15) => values returned are for depths [10]
     */
    geotoolkit.welllog.data.las.LasStreamDataSection.prototype.getDataInRangeByIndex = function(start, end, indexes, success, error){};

/**
 * LAS writer for LAS version 2.0
 * @class geotoolkit.welllog.data.las.Las20Writer
 * @param {geotoolkit.data.NumericalDataSeries} indexData data series which stores index values (depth, time or index)
 */
geotoolkit.welllog.data.las.Las20Writer = {};
    /**
     * Sets company name
     * @param {string} value value
     * @returns {geotoolkit.welllog.data.las.Las20Writer} this
     */
    geotoolkit.welllog.data.las.Las20Writer.prototype.setCompanyName = function(value){};
    /**
     * Sets well name
     * @param {string} value value
     * @returns {geotoolkit.welllog.data.las.Las20Writer} this
     */
    geotoolkit.welllog.data.las.Las20Writer.prototype.setWellName = function(value){};
    /**
     * Sets field
     * @param {string} value value
     * @returns {geotoolkit.welllog.data.las.Las20Writer} this
     */
    geotoolkit.welllog.data.las.Las20Writer.prototype.setField = function(value){};
    /**
     * Sets location
     * @param {string} value value
     * @returns {geotoolkit.welllog.data.las.Las20Writer} this
     */
    geotoolkit.welllog.data.las.Las20Writer.prototype.setLocation = function(value){};
    /**
     * Sets province
     * @param {string} value value
     * @returns {geotoolkit.welllog.data.las.Las20Writer} this
     */
    geotoolkit.welllog.data.las.Las20Writer.prototype.setProvince = function(value){};
    /**
     * Sets county
     * @param {string} value value
     * @returns {geotoolkit.welllog.data.las.Las20Writer} this
     */
    geotoolkit.welllog.data.las.Las20Writer.prototype.setCounty = function(value){};
    /**
     * Sets state
     * @param {string} value value
     * @returns {geotoolkit.welllog.data.las.Las20Writer} this
     */
    geotoolkit.welllog.data.las.Las20Writer.prototype.setState = function(value){};
    /**
     * Sets country
     * @param {string} value value
     * @returns {geotoolkit.welllog.data.las.Las20Writer} this
     */
    geotoolkit.welllog.data.las.Las20Writer.prototype.setCountry = function(value){};
    /**
     * Sets service company
     * @param {string} value value
     * @returns {geotoolkit.welllog.data.las.Las20Writer} this
     */
    geotoolkit.welllog.data.las.Las20Writer.prototype.setServiceCompany = function(value){};
    /**
     * Sets date
     * @param {string} value value
     * @returns {geotoolkit.welllog.data.las.Las20Writer} this
     */
    geotoolkit.welllog.data.las.Las20Writer.prototype.setDate = function(value){};
    /**
     * Sets unique well id
     * @param {string} value value
     * @returns {geotoolkit.welllog.data.las.Las20Writer} this
     */
    geotoolkit.welllog.data.las.Las20Writer.prototype.setUWI = function(value){};
    /**
     * Sets API number
     * @param {string} value value
     * @returns {geotoolkit.welllog.data.las.Las20Writer} this
     */
    geotoolkit.welllog.data.las.Las20Writer.prototype.setAPINumber = function(value){};
    /**
     * Sets licence number
     * @param {string} value value
     * @returns {geotoolkit.welllog.data.las.Las20Writer} this
     */
    geotoolkit.welllog.data.las.Las20Writer.prototype.setLicenceNumber = function(value){};
    /**
     * Save
     * @param {geotoolkit.util.stream.Stream} stream stream to save file
     */
    geotoolkit.welllog.data.las.Las20Writer.prototype.save = function(stream){};
    /**
     * Adds parameter
     * @param {string} mnemonic mnemonic
     * @param {string} unit unit
     * @param {string} value value
     * @param {string} description description
     * @returns {geotoolkit.welllog.data.las.Las20Writer}
     */
    geotoolkit.welllog.data.las.Las20Writer.prototype.addParameter = function(mnemonic, unit, value, description){};
    /**
     *
     * @param {geotoolkit.data.NumericalDataSeries} curveData curve data series
     * @param {string} [mnemonic] mnemonic
     * @param {string} [unit] unit
     * @param {string} [value] value
     * @param {string} [description] description
     * @returns {geotoolkit.welllog.data.las.Las20Writer}
     */
    geotoolkit.welllog.data.las.Las20Writer.prototype.addCurve = function(curveData, mnemonic, unit, value, description){};
    /**
     * Adds comment to version section
     * @param {number} position position
     * @param {string} comment comment
     * @returns {geotoolkit.welllog.data.las.Las20Writer}
     */
    geotoolkit.welllog.data.las.Las20Writer.prototype.addVersionComment = function(position, comment){};
    /**
     * Adds comment to well section
     * @param {number} position position
     * @param {string} comment comment
     * @returns {geotoolkit.welllog.data.las.Las20Writer}
     */
    geotoolkit.welllog.data.las.Las20Writer.prototype.addWellComment = function(position, comment){};
    /**
     * Adds comment to parameter section
     * @param {number} position position
     * @param {string} comment comment
     * @returns {geotoolkit.welllog.data.las.Las20Writer}
     */
    geotoolkit.welllog.data.las.Las20Writer.prototype.addParameterComment = function(position, comment){};
    /**
     * Adds comment to curve section
     * @param {number} position position
     * @param {string} comment comment
     * @returns {geotoolkit.welllog.data.las.Las20Writer}
     */
    geotoolkit.welllog.data.las.Las20Writer.prototype.addCurveComment = function(position, comment){};
    /**
     *
     * @param {number} value null value
     * @returns {geotoolkit.welllog.data.las.Las20Writer}
     */
    geotoolkit.welllog.data.las.Las20Writer.prototype.setNullValue = function(value){};
    /**
     *
     * @returns {number}
     */
    geotoolkit.welllog.data.las.Las20Writer.prototype.getNullValue = function(){};

